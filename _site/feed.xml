

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>HyunHyun's BLOG</title>
  <subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle>
  <updated>2022-02-26T15:00:36+09:00</updated>
  <author>
    <name>Hyun</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en-US"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2022 Hyun </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>섹션1 - 객체 지향 설계와 스프링</title>
    <link href="http://localhost:4000/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84%EC%99%80%EC%8A%A4%ED%94%84%EB%A7%81/" rel="alternate" type="text/html" title="섹션1 - 객체 지향 설계와 스프링" />
    <published>2022-02-26T00:00:00+09:00</published>
  
    <updated>2022-02-26T13:05:58+09:00</updated>
  
    <id>http://localhost:4000/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84%EC%99%80%EC%8A%A4%ED%94%84%EB%A7%81/</id>
    <content src="http://localhost:4000/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84%EC%99%80%EC%8A%A4%ED%94%84%EB%A7%81/" />
    <author>
      <name>Hyun</name>
    </author>

  
    
    <category term="Spring" />
    
    <category term="Basic" />
    
  

  
    <summary>
      





      좋은 객체 지향 프로그래밍이란?

  추상화
  캡슐화
  상속
  다형성


좋은 객체 지향 설계의 5가지 원칙 (SOLID)

  S  - Single Responsibility Principle(SRP) 단일 책임 원칙
  O - Open/Closed Principle(OCP)
  L - 리스코프 치환 법칙(Liskov substitution principle)
  I - Interface Segregation Principle(ISP)  인터페이스 분리 법칙
  
    D - Dependency Inversion Principle(DIP) 의존관계 역전 원칙
  
  SRP
-&amp;gt; 한 클래스는 하나의 책임만 가진다
-&amp;gt; 중요한 기준은 변경으로 변경시 파급효과가 적으면 성공적으로 원칙을...
    </summary>
  

  </entry>

  
  <entry>
    <title>섹션 6 - 컴포넌트 스캔</title>
    <link href="http://localhost:4000/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%8A%A4%EC%BA%94/" rel="alternate" type="text/html" title="섹션 6 - 컴포넌트 스캔" />
    <published>2022-02-26T00:00:00+09:00</published>
  
    <updated>2022-02-26T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%8A%A4%EC%BA%94/</id>
    <content src="http://localhost:4000/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%8A%A4%EC%BA%94/" />
    <author>
      <name>Hyun</name>
    </author>

  
    
    <category term="Spring" />
    
    <category term="Basic" />
    
  

  
    <summary>
      





      @Component 애노테이션 붙은 객체 자동 스캔하여 bean으로 등록
@Autowired로 의존객체 주입

@ComponentScan (
basePackages =“hello.core”
)

컴포넌트 스캔할 위치 지정
basePackages 로 탐색 패키지 위치설정 (해당 위치포함 하위패키지까지 탐색)

지정하지 않을 경우 @ComponentScan 붙은 설정정보 클래스의 패키지가 시작 위치

이외 전부 내부에는 @Component 포함하여 전부 스캔대상
@Component
@Controller  :웹 mvc 컨트롤러
@Service : 스프링 비즈니스로직
@Repository : 데이터 접근 계층
@Configuration :설정 정보


  includeFilters, excludeFilters...
    </summary>
  

  </entry>

  
  <entry>
    <title>섹션 7 - 의존관계 자동 주입</title>
    <link href="http://localhost:4000/posts/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/" rel="alternate" type="text/html" title="섹션 7 - 의존관계 자동 주입" />
    <published>2022-02-26T00:00:00+09:00</published>
  
    <updated>2022-02-26T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/</id>
    <content src="http://localhost:4000/posts/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/" />
    <author>
      <name>Hyun</name>
    </author>

  
    
    <category term="Spring" />
    
    <category term="Basic" />
    
  

  
    <summary>
      





      의존관계 주입방법

  생성자 주읩   -&amp;gt; 제일 추천하는 방법
    
      생성시점에 바로 주입하므로 final 키워드 사용가능해서 주입이 안될경우 컴파일 오류가 나서 더큰 오류 방지 가능함
    
  
  수정자 주입(setter 주입)
  필드 주입
    
      비추천 테스트도 어렵고 단순 테스트코드 사용 방법 불가, 스프링을 띄우는 @SpringBootTest(더 느림) 유지보수 어려움
      결국 테스트하려면 getter, setter 만들게 될거고 그러먼 getter,setter로 하지?
    
  
  일반 메서드 주입


옵션처리
주입할 스프링 빈이 없으면 오류남 -&amp;gt; @Autowired(required =true) 가 기본설정이라

  @Autowired...
    </summary>
  

  </entry>

  
  <entry>
    <title>섹션2 - 스프링 핵심 원리 이해1 - 예제 만들기</title>
    <link href="http://localhost:4000/posts/%EC%98%88%EC%A0%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9B%90%EB%A6%AC%EC%A0%81%EC%9A%A9/" rel="alternate" type="text/html" title="섹션2 - 스프링 핵심 원리 이해1 - 예제 만들기" />
    <published>2022-02-26T00:00:00+09:00</published>
  
    <updated>2022-02-26T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%98%88%EC%A0%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9B%90%EB%A6%AC%EC%A0%81%EC%9A%A9/</id>
    <content src="http://localhost:4000/posts/%EC%98%88%EC%A0%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9B%90%EB%A6%AC%EC%A0%81%EC%9A%A9/" />
    <author>
      <name>Hyun</name>
    </author>

  
    
    <category term="Spring" />
    
    <category term="Basic" />
    
  

  
    <summary>
      





      예제 만들기 및 객체지향 원리 적용
요구사항:  주문, 고객 이 있고 고객의 등급이 vip인 경우에 할인정책을 적용한다
할인정책은 변경가능하다, 어떤 db를 사용할지 정하지 못했다



섹션 3 - 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
Junit5을 이용하여 테스트코드 작성
@Test를 이용하면 main함수가 아니더라도 코드 수행 가능
@BeforeEach는 각 테스트 호출전에 각각 수행됨
@DisplayName(“테스트 이름”)      -Junit5 부터

AppConfig라는 설정하는 클래스를 별도로 만들어
구현 객체 생성, 연결하는 별도 설정의 클래스
-&amp;gt; DIP, 역할 분리 만족됨
-&amp;gt; DI 의존성 주입해주는 역할

IoC, DI 그리고 컨테이너
IoC: 제어의 역전 -...
    </summary>
  

  </entry>

  
  <entry>
    <title>섹션 5 - 싱글톤 컨테이너</title>
    <link href="http://localhost:4000/posts/%EC%8B%B1%EA%B8%80%ED%86%A4%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" rel="alternate" type="text/html" title="섹션 5 - 싱글톤 컨테이너" />
    <published>2022-02-26T00:00:00+09:00</published>
  
    <updated>2022-02-26T00:00:00+09:00</updated>
  
    <id>http://localhost:4000/posts/%EC%8B%B1%EA%B8%80%ED%86%A4%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/</id>
    <content src="http://localhost:4000/posts/%EC%8B%B1%EA%B8%80%ED%86%A4%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" />
    <author>
      <name>Hyun</name>
    </author>

  
    
    <category term="Spring" />
    
    <category term="Basic" />
    
  

  
    <summary>
      





      싱글톤 패턴 : 클래스의 인스턴스가 딱 1개 생성되도록 보장 디자인 패턴

싱글톤 패턴 구현방법
1) static영역에 인스턴스 하나를 미리생성해서 올려둠
2) 인스턴스 요청시 getInstance() 로  반환(항상 같은 instance)
3) 생성자 private으로 막음

싱글톤 패턴 단점

  코드 자체가 많아짐
  클라이언트가 구체클래스에 의존한다 -&amp;gt; DIP 위반 -&amp;gt; OCP 원칙 위배할 가능성 높음
  테스트 어려움
  유연성이 떨어짐


싱글톤 컨테이너는 이러한 문제점 해결하면서 Bean을 싱글톤으로 관리함

유의점

  여러 클라이언트가 하나 객체 사용하기 때문에 stateless하게 설계해야한다
    
      특정 클라이언트에 의존적인 필드 있으면 안된다
      특...
    </summary>
  

  </entry>

</feed>


