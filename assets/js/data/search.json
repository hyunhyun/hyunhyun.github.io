[ { "title": "AWS KMS 이용 암호화", "url": "/posts/AWS-KMS-%EC%9D%B4%EC%9A%A9-%EC%95%94%ED%98%B8%ED%99%94/", "categories": "AWS", "tags": "AWS", "date": "2023-07-21 00:00:00 +0900", "snippet": "고객관리형키 KMS 키로 암호화 적용iam 사용자에 보안자격증명 탭에서 액세스 키 만들기를 선택한다.aws cli 타입을 선택해서 하겠다.secret_access_key는 바로 별도로 저장해주어야한다. 이후에 조회가 불가하다.EC2에 aws cli를 통해 configure정보를 아래처럼 등록해준다.EC2에 AWSKeyManagementServicePowerUser를 추가해줍니다.소스에 build.gradle에 아래와 같은 dependency를 추가한다. //aws implementation platform(&#39;com.am..." }, { "title": "Code Build 사용하기", "url": "/posts/Code-Build-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "AWS", "tags": "AWS", "date": "2023-07-20 00:00:00 +0900", "snippet": "AWS code pipeline 활용하기 위해 code build 빌드 프로젝트 생성aws code pipeline을 활용하여 cicd를 구축하기 위한 단계로 소스 리파지토리는 aws code commit 사용 build 단계에서는 code build를 사용 deploy 단계에서는 code deploy 사용CodeBuild에서 빌드 프로젝트를 생성해준다빌드할 소스의 위치를 전에 생성한 git commit으로 선택후 repository, branch 을 선택해준다환경이 운영체제는 해당 사항에 맞게 선택해주고corretto1..." }, { "title": "AWS Code pipeline", "url": "/posts/AWS-Code-pipeline-%EA%B5%AC%EC%B6%95/", "categories": "AWS", "tags": "AWS", "date": "2023-07-20 00:00:00 +0900", "snippet": "AWS code pipeline cicd 구축하기이전 게시글에서 aws code commit, code build, code deploy를 만들었다.이들을 연결하여 pipeline을 생성하여 cicd를 구축해보자.소스 공급자로 이전에 code commit에 저장된 리파지토리를 선택한다.빌드 스테이지에서는 이전에 생성한 code build project를 선택한다.배포 스테이지에서는 이전에 생성한 code deploy application을 선택한다.이후 code commit 해당 리파지토리에 push가 일어나면 자동으로 sou..." }, { "title": "AWS Code deploy", "url": "/posts/AWS-Code-deploy/", "categories": "AWS", "tags": "AWS", "date": "2023-07-20 00:00:00 +0900", "snippet": "AWS code deploycode deploy를 생성하여 배포하는 과정을 만들어보겠다.code deploy에 들어가서 code deploy application을 생성한다.iam role 로 아래와 같이 AWSCodeDeployRole 권한이 있는 role을 생성한다.아래와 같이 배포 그룹을 생성한다. 배포에 추가할 인스턴스 조합으로 EC2 인스턴스를 선택한다. 그리고 아래에서 적절한 생선한 ec2 중 적절한 ec2를 선택한다.로드밸런스는 선택하지 않고 단일 ec2에만 적용할 것이니 로드 밸런싱 활성화는 해제해 준다.소스 코..." }, { "title": "AWS Code Commit 사용하기", "url": "/posts/AWS-Code-Commit-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "AWS", "tags": "AWS", "date": "2023-07-18 00:00:00 +0900", "snippet": "Repository로 AWS Code Commit 사용하기code commit 에서 리파지토리를 새로 생성해준다.iam 메뉴에 가서 사용자를 새로 생성한다.사용자의 권한에 AWSCodeCommitFullAccess권한을 추가해준다.사용자의 보안자격 증명 탭에 들어가면 아래에AWS CodeCommit에 대한 HTTPS Git 자격 증명에 아래와 같이 자격 증명을 하나 생성한다. 이때 암호는 따로 저장해 둔다.그리고 기존의 git 사용법 대로 아래 명령어 순서대로 수행하여 준다.git initgit add .git commit -..." }, { "title": "gradle profile 다르게 설정", "url": "/posts/gradle-profile-%EC%84%A4%EC%A0%95/", "categories": "Spring, Spring boot 세팅", "tags": "API, Spring boot 세팅, Swagger", "date": "2023-06-16 00:00:00 +0900", "snippet": "gradle profile 별로 다르게 설정하기gradle이 아닌 gradelw -gradle wrapper를 사용하는 이유gradlew를 이용하여 빌드하면 로컬환경 java와 gradle버전과 상관없이 새로운 프로젝트를 빌드할 수 있다.gradle 설정profile의 기본값 dev로 설정ext.profile = (!project.hasProperty(&#39;profile&#39;)) || !profile) ? &#39;dev&#39; : profile//리소스 디렉토리 추가sourceSets{ main{ resour..." }, { "title": "Swagger UI 설정하기", "url": "/posts/swagger%EC%84%A4%EC%A0%95/", "categories": "Spring, Spring boot 세팅", "tags": "API, Spring boot 세팅, Swagger", "date": "2023-06-15 00:00:00 +0900", "snippet": "Spring Boot 3.0 이상에서 Swagger 설정하기Swagger UI란 Swagger UI allows anyone — be it your development team or your end consumers — to visualize and interact with the API’s resources without having any of the implementation logic in place. It’s automatically generated from your OpenAPI (formerly known a..." }, { "title": "AWS RDS 암호로 연결", "url": "/posts/AWS-RDS-%EC%95%94%ED%98%B8%EB%A1%9C-%EC%97%B0%EA%B2%B0/", "categories": "AWS", "tags": "AWS", "date": "2023-06-15 00:00:00 +0900", "snippet": "AWS RDS 암호로 연결하기AWS Aurora 생성 후 AWS에서 RDS 생성 시 암호를 직접 정해서 이를 이용해서 RDS에 연결 Secrets Manager를 이용해서 자동으로 암호를 생성해서 이를 AWS에서 안전하게 저장하고 이를 이용해서 연결 이렇게 방법으로 spring boot어플리케이션에서 aws rds에 접속하는 방법을 보도록 하겠다. 먼저 암호를 생성해서 이를 통해 접속하는 방법을 알아보겠다. Auroa 생성엔진 버전은 Aurora (MySQL 5.7) 2.11.2 로 기본 선택 되어있는 ..." }, { "title": "Cloud Native Application 아키텍처와 고려사항", "url": "/posts/Cloud-Native-Application-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD/", "categories": "MSA", "tags": "MSA", "date": "2022-04-25 00:00:00 +0900", "snippet": "Cloud Native Application - CI/CD 지속적인 통합, CI(Continuous Integration) ex) Jenkins, Team CI, Travis CI 빌드, 테스트 까지 수행 지속적 배포 CD Continuous Delivery : 수동반영이 필요한 경우 continuous delivery 이후 , 수동반영 Continuous Deployment : 자동반영 까지 배포전략 카나리 배포 ..." }, { "title": "Kafka spring 간단 예제", "url": "/posts/kafka%EC%98%88%EC%A0%9C/", "categories": "Kafka, example", "tags": "kafka", "date": "2022-04-06 00:00:00 +0900", "snippet": "spring 환경에서 controller로 메시지 요청이 들어오면producer에서 해당 메시지 내용으로 message broker로 메시지 전달consumer에서 해당 토픽으로 message 읽는 예제를 구현해보았습니다.pom.xml에 해당 dependency 추가&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.kafka&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-kafka&amp..." }, { "title": "프록시", "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "Em.find() vs em.getReference()Find- 직접 구현체를 가져옴getReference - 바로 쿼리 안함, 필요한 칼럼 요청 시점에 조회데이터베이스 조회를 미루는 가짜 엔티티 객체(프록시) 가져옴프록시 실제 클래스 상속받아서 겉 모습은 같음 실제 객체의 참조(target) 보관프록시 객체 초기화 동작 방식 클라이언트가 값 요청시 값 없으면 프록시 객체에서 영속성 컨텍스트에 초기화 요청 db조회 target(실제 객체 참조)에 실제 객체 참조값 넣음 Target 통해서 실제 객체 set 함수이용해..." }, { "title": "프로젝션과 페이징", "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%EC%85%98/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어1-기본문법쿼리로 가져온 값의 타입에 따라 나눠짐 엔티티 프로젝션 - 가져온값 들 영속성 컨텍스트로 관리됨 임베디드 타입 프로젝션 스칼라 타입 프로젝션여러값 조회Select m.username, m.age from Member as mString과 int 타입이 일치하지 않음//Object[]로 매핑List&amp;lt;Object[]&amp;gt; resultList = em.createQuery(&quot;select m.username, m.age from Member m”) .getRes..." }, { "title": "페치조인 한계", "url": "/posts/%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8%ED%95%9C%EA%B3%84/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어2-중급문법 페치 대상 조인하는 테이블에 alias 줄 수 없어 둘이상 컬렉션 페치 조인 할수 없다 컬렉션 페치 조인하면 페이징 API(setFirstResult, setMaxResult) 사용불가 일대일, 다대일 단일 값 연관 필드들 은 페치조인해도 페이징 가능일대다 인경우 한 줄만 가져와 했을때 팀A에 회원1, 회원2 있는데 2줄중 한줄만 가져오면 팀A에 회원1 만 있는걸로 가져오게됨 쓰면 안돼 페이징시 fetch join 미사용시 성능이슈 해결법fetch join 미사용시 컬..." }, { "title": "페치조인 기본", "url": "/posts/%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8%EA%B8%B0%EB%B3%B8/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어2-중급문법N+1문제 해결 함 sql 조인 종류 x jpql에서 성능 최적화를 위해 제공하는 기능 연관도니 엔티티나 컬렉션을 sql 한번에 함께 조회하는 기능 join fetch 명령어 사용 페치 조인 ::= [LEFT[OUTER] |INNER] JOIN FETCH 조인경로[JPQL]Select m from Member m join fetch m.team번역된[SQL]Select M.*, T.* from Member m INNER JOIN Team t on m.team_id = t.idJPQL에서는 se..." }, { "title": "지연로딩 즉시로딩", "url": "/posts/%EC%A6%89%EC%8B%9C%EB%A1%9C%EB%94%A9%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "@ManyToOne(fetch = FetchType.LAZY) - 해당 객체 프록시 객체로 가져옴FetchType.EAGER - 즉시 로딩 실제 객체 가져옴가급적 지연 로딩 사용 즉시 로딩 예상하지 못한 sql 발생 [중요!!] 즉시 로딩 jpql에서 N+1 문제 일으킴 처음 날리려는 쿼리 1개 그거로 인해서 데이터 개수 N만큼 쿼리 더나감 .find는 jpa내부에서 pk로 최적화되는데 join 하고 jpql은 sql로 번역되서 나감 select * from ..." }, { "title": "영속성전이 CASCADE", "url": "/posts/%EC%98%81%EC%86%8D%EC%84%B1%EC%A0%84%EC%9D%B4/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 같이 영속성 컨텍스트에 엔티티에 저장상속관계 이런거랑 상관 없음, 연관관계 매핑하는거랑도 상관없음종류 all persist remove merge refresh detach사용할 수 있을때 단일 소유자 라이프사이클이 동일할때고아 객체부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제orphanRemoval = true@OneToMany(orpahnRemoval= true)부모객체로 부터 remove시 child객체 자체도 delete부모객체 지워도 자식..." }, { "title": "연관관계 매핑", "url": "/posts/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EB%A7%A4%ED%95%91/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "다대일 매핑을 사용하도록일인쪽에서 접근해야하면 다대일 양방향 사용일대다 매핑은 일이 연관관계의 주인 테이블은 다쪽에 외래키가 있음 객체와 테이블 차이로 반대편 테이블의 외래키를 관리하게 됨 다른 테이블로 update 쿼리 나가는등 유지보수 어려워짐 @JoinColumn 꼭 추가 - 안그러면 join table이 새로 생김일대일주테이블이나 대상테이블 둘 중 하나 외래키 선택 가능외래키에 데이터베이스 유니크 조건 추가다대다 사용하지마JoinTable 생성해서 지joinTable에 조인만 하고 다른 ..." }, { "title": "JPQL 벌크연산", "url": "/posts/%EB%B2%8C%ED%81%AC%EC%97%B0%EC%82%B0/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어2-중급문법Sql update, delete 한건 자동으로 호출되는게 아닌 이외것String qlString = &quot;update Employee e set e.salary = e.salary * 1.5 &quot; + &quot;where e.year &amp;gt; :year&quot;;int resultCount = em.createQuery(qlString) .setParameter(&quot;year&quot;, 3) ..." }, { "title": "다형성 쿼리", "url": "/posts/%EB%8B%A4%ED%98%95%EC%84%B1%EC%BF%BC%EB%A6%AC/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어2-중급문법type [JPQL}select i from Item I where type(i) in (Book, Movie) [SQL]select i from Item Iwhere i.DTYPE in (‘B’, ‘M’)TREAT [JPQL] Select i from Item IWhere treat(I as Book).author = ‘Kim’ [SQL] Select i.* from Item IWhere i.DTYPE = ‘B’ and i.author = ‘Kim’ 엔티티 직접..." }, { "title": "고급매핑", "url": "/posts/%EA%B3%A0%EA%B8%89%EB%A7%A4%ED%95%91/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "상속관계 매핑@Inheritance(strategy = InheritanceType.JOINED) - 조인 하는 방식 JOINED SINGLE_TABLE - jpa default TABLE_PER_CLASS - 각 구현체 별로 만 구현 부모객체 안 만듬@DiscriminatorColumn(name =“DTYPE”) - 어떤 상속 구현체인지 부모객체에서 표현@DiscriminatorValue - 자식 쪽에서 부모객체에 무슨 값으로 discriminator column 값넣을지 JOINED 장점 ..." }, { "title": "경로표현식", "url": "/posts/%EA%B2%BD%EB%A1%9C%ED%91%9C%ED%98%84%EC%8B%9D/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어2-중급문법점을 찍어 객체 그래프를 탐색 하는것 상태 필드 : m.username(string) 단순히 값을 저장하기 위한 필드 경로 탐색 끝, 탐색X(더 탐색할게 없어) 단일 값 연관필드 : m.team(member의 team) 연관관계를 위한필드 @ManyToOne, @OneToOne, 대상이 엔티티 묵시적 내부조인(inner join) 발생, 탐색O 컬렉션값 연관필드: m.orders(orders 컬렉션) ..." }, { "title": "객체지향쿼리 기본문법", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어1-기본문법Jpql테이블이 아닌 객체를 대상으로 쿼리를 날림Ansi 표준 sql 문법 다 지원(select, from,where, join등)List&amp;lt;Member&amp;gt; result = em.createQuery( &quot;select m from Member m where m.username like ‘%Kim%&#39;”, Member.class).getResultList();Criteria문법 동적쿼리가 jpql 보다 편리함 - 실무에서 쓰기 복잡함대신에 Que..." }, { "title": "값 타입", "url": "/posts/%EA%B0%92%ED%83%80%EC%9E%85/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "Embedded 타입 객체직접 정의한 새로운 값 타입Equals, hashcode 구현해야함값 타입은 불변 immutable 해야함변경하고 싶으면 새로운 인스턴스 자체로 완전히 교체 해야함.Set 함수들 생성 자체를 하지 말거나 ,private으로 선언 후생성자 통해서만 값 세팅할 수 있도록생명주기를 엔티티에 의존함엔티티 값을 바꾸면 해당 엔티티의 값타입 컬렉션도 변함persist(member);//엔티티만 persist하면 값 타입 같이 저장됨Cascade , 고아객체 제거 기능 필수로 가지는거 같이 행동(값타입과 동일한데..." }, { "title": "join", "url": "/posts/join/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어1-기본문법 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t 외부 조인: SELECT m FROM Member m LEFT [OUTER] JOIN m.team t 세타 조인: select count(m) from Member m, Team t where m.username = t.name 서브쿼리ALL 모두 만족하면 참ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참 전체 상품 각각의 재고보다 주문량이 많..." }, { "title": "JPQL기본 문법과 쿼리 API", "url": "/posts/JPQL%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-20 00:00:00 +0900", "snippet": "객체지향쿼리언어1-기본문법객체지향적인 sqlSQL을 추상화해서 특정데이터베이스 sql에 의존하지 않는다결국 sql로 변환Select m from Member as m where m.age &amp;gt;19 대소문자 구분함 jpql 키워드는 대소문자 구분 안함(select, from ,where) 테이블이 아니라 엔티티 이름을 사용 별칭은 필수(m)(as 는 생략가능)TypedQuery - 반환타입 명확Query - 반환타입 불명확TypedQuery&amp;lt;Member&amp;gt; select_m_from_me..." }, { "title": "외벽점검(60062)", "url": "/posts/%EC%99%B8%EB%B2%BD%EC%A0%90%EA%B2%80/", "categories": "Algorithm, etc", "tags": "프로그래머스, 알고리즘", "date": "2022-03-18 00:00:00 +0900", "snippet": "직접 구현하기https://programmers.co.kr/learn/courses/30/lessons/60062제공 테스트케이스 n weak dist result 12 [1, 5, 6, 10] [1, 2, 3, 4] 2 12 [1, 3, 4, 9, 10] [3, 5, 7] 1 추가 테스트케이스6 10 12 14 테스트케이스 n weak ..." }, { "title": "복싱선수 랭킹 순위(49191)", "url": "/posts/%EB%B3%B5%EC%8B%B1%EC%84%A0%EC%88%98%EB%9E%AD%ED%82%B9/", "categories": "Algorithm, graph", "tags": "graph, 프로그래머스, 알고리즘", "date": "2022-03-14 00:00:00 +0900", "snippet": "graphhttps://programmers.co.kr/learn/courses/30/lessons/49191플로이드 워셜 알고리즘을 참고해서 풀어야 된다고 한다.알고리즘 자체보다는 그래프 방향성으로 해당 정점(선수)에 도착할 수 있는 정점(선수) 수는 - 해당 정점(선수)를 이기는 선수 수해당 점정(선수)에서 갈 수 있는 정점(선수)의 수는 - 해당 정점(선수)가 이기는 선수 수이 수의 개수가 n-1 일때 순위 확정 가능 하다해당 블로그 참고// n = 5;// int[][] results = { { 4, 3 }, { 4, ..." }, { "title": "기둥과보(60061)", "url": "/posts/%EA%B8%B0%EB%91%A5%EA%B3%BC%EB%B3%B4/", "categories": "Algorithm, etc", "tags": "프로그래머스, 알고리즘", "date": "2022-03-14 00:00:00 +0900", "snippet": "직접 구현하기https://programmers.co.kr/learn/courses/30/lessons/60061제공 테스트케이스 n build_frame result 5 [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] ..." }, { "title": "단방향 양방향 연관관계", "url": "/posts/%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-13 00:00:00 +0900", "snippet": "단방향 연관관계테이블은 id 로 조인해오지만(방향성이 없음) 외래키 하나로 양쪽 조인 가능 객체는 참조값으로 가져옴 참조용 필드가 있는 쪽으로만 참조 가능 여기서 둘 사이의 갭이 생김양방향 연관관계연관관계의 주인이 있어야하는 이유:테이블은 fk 설정으로 어느쪽 테이블에서 조인해서도 반대쪽 값 가져올수 있음(주인이 필요없음) 객체는 다름 참조값이 있는쪽에서만 접근가능 양쪽에 조회가능하게 만들어 놓으면 () 문제점 : 회원의 팀 정보 변경하려 할때 (Member객체의 TEAM_ID..." }, { "title": "기본키 매핑", "url": "/posts/%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A7%A4%ED%95%91/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-13 00:00:00 +0900", "snippet": "@Entity, @Table@Column@Id, @GeneratedValue데이터베이스 스키마 자동생성hibernate.hbm2ddl.auto&amp;lt;property name=“hibernate.hbm2ddl.auto” value=“create” /&amp;gt; create -기존 테이블 drop 후 생성 create-drop - 생성후 종료시점에 drop update - 변경만 alter validate - 엔티티와 테이블 정상 매핑만 확인 none운영에서는 validate나 none만 사용@Column@Te..." }, { "title": "JPA 소개, 시작", "url": "/posts/JPA%EC%86%8C%EA%B0%9C1/", "categories": "JPA, JPA_Basic", "tags": "JPA", "date": "2022-03-12 00:00:00 +0900", "snippet": "SQL MapperSQL Mapper : myBatis, iBatis-JDBC 보다 코드는 줄지만 SQL작성해야됨JPA는 JPA 가 sql 생성해서 객체 저장이나 조회함SQL 중심적인 개발의 문제점 객체답게 모델링 할수록 매핑 작업만 늘어남 엔티티를 신뢰하지못하게 되는문제 .getTeam() 으로 엔티티 안의 값을 가지고 오려해도 해당 쿼리 조회 범위를 직접 소스를 통해 확인해봐야한다 객체를 자바 컬렉션에 저장하듯이 db에 저장할 수 없을까?해서 나온 것이 JPA다.필요 요소 Persistence..." }, { "title": "Carpet(42842)", "url": "/posts/%EC%B9%B4%ED%8E%98%ED%8A%B8%ED%81%AC%EA%B8%B0/", "categories": "Algorithm, 완전탐색", "tags": "완전탐색, BruteForce, 프로그래머스, 알고리즘", "date": "2022-03-03 00:00:00 +0900", "snippet": "완전탐색 BruteForcehttps://programmers.co.kr/learn/courses/30/lessons/42842?language=java제공 테스트케이스 brown yellow answer 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 조건 가로는 세로 보다 크거나 같음 brown은 8 이상 5,000 이하 ye..." }, { "title": "ConnectIsland(42861)", "url": "/posts/%EC%84%AC%EC%97%B0%EA%B2%B0/", "categories": "Algorithm, greedy", "tags": "greedy, Kruskal알고리즘, 프로그래머스, 알고리즘", "date": "2022-03-03 00:00:00 +0900", "snippet": "완전탐색 BruteForcehttps://programmers.co.kr/learn/courses/30/lessons/42842?language=java제공 테스트케이스 n costs return 4 [[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]] 4 MST - minimal spanning tree(최소신장트리)모든 node들이 연결되면서 사이클이 발생하지 않고간선의 가중치가 최소인 트리이 두 알고리즘을 ..." }, { "title": "섹션 6 - 컴포넌트 스캔", "url": "/posts/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%8A%A4%EC%BA%94/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "@Component 애노테이션 붙은 객체 자동 스캔하여 bean으로 등록 후@Autowired로 의존객체 주입해서 사용 가능하다.컴포넌트 스캔할 위치 지정basePackages 로 탐색 패키지 위치설정 (해당 위치포함 하위패키지까지 탐색)@ComponentScan (basePackages =“hello.core”)지정하지 않을 경우 @ComponentScan 붙은 설정정보 클래스의 패키지가 시작 위치이외 전부 내부에는 @Component 포함하여 전부 스캔대상(내부에 @Component 명시되어있다.) @Component ..." }, { "title": "섹션 7 - 의존관계 자동 주입", "url": "/posts/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "의존관계 주입방법 생성자 주읩 -&amp;gt; 제일 추천하는 방법 생성시점에 바로 주입하므로 final 키워드 사용가능해서 주입이 안될경우 컴파일 오류가 나서 더큰 오류 방지 가능함 수정자 주입(setter 주입) 필드 주입 비추천 테스트도 어렵고 단순 테스트코드 사용 방법 불가, 스프링을 띄우는 @SpringBootTest(더 느림) 유지보수 어려움 결국 테스트하려면 getter, setter 만들게 될거고 그러먼 getter,setter로 하지? 일..." }, { "title": "섹션2 - 스프링 핵심 원리 이해1 - 예제 만들기", "url": "/posts/%EC%98%88%EC%A0%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9B%90%EB%A6%AC%EC%A0%81%EC%9A%A9/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "예제 만들기 및 객체지향 원리 적용요구사항: 주문, 고객 이 있고 고객의 등급이 vip인 경우에 할인정책을 적용한다할인정책은 변경가능하다, 어떤 db를 사용할지 정하지 못했다섹션 3 - 스프링 핵심 원리 이해2 - 객체 지향 원리 적용Junit5을 이용하여 테스트코드 작성@Test를 이용하면 main함수가 아니더라도 코드 수행 가능@BeforeEach는 각 테스트 호출전에 각각 수행됨@DisplayName(“테스트 이름”) -Junit5 부터AppConfig라는 설정하는 클래스를 별도로 만들어구현 객체 생성, 연결하..." }, { "title": "섹션 5 - 싱글톤 컨테이너", "url": "/posts/%EC%8B%B1%EA%B8%80%ED%86%A4%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "싱글톤 패턴 : 클래스의 인스턴스가 딱 1개 생성되도록 보장 디자인 패턴싱글톤 패턴 구현방법 static영역에 인스턴스 하나를 미리생성해서 올려둠 인스턴스 요청시 getInstance() 로 반환(항상 같은 instance) 생성자 private으로 막음싱글톤 패턴 단점 코드 자체가 많아짐 클라이언트가 구체클래스에 의존한다 -&amp;gt; DIP 위반 -&amp;gt; OCP 원칙 위배할 가능성 높음 테스트 어려움 유연성이 떨어짐싱글톤 컨테이너는 이러한 문제점 해결하면서 Bean을 싱글톤으로 관리함유의점 여러..." }, { "title": "섹션 4 - 스프링 컨테이너와 스프링 빈", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%8A%A4%ED%94%84%EB%A7%81%EB%B9%88/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "ApplicationContext: 스프링 컨테이너ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);//1)모든 빈 이름 갖고오기String[] names = ac.getBeanDefinitionNames(); //2)빈 갖고오기Object bean = ac.getBean(names[1]); //3) BeanDefinition.ROLE_APPLICATION - 사용자가 정의한 빈//ROLE_INFRASTRUCTURE - 스프링 내부에서..." }, { "title": "섹션 9 - 빈 스코프", "url": "/posts/%EB%B9%88%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "스코프는 빈이 존재할 수 있는 범위를 뜻한다. 이제까지 사용한 스프링빈은 기본적으로 싱글 스코프로 생성한다.스코프 종류 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성, 의존관계 주입,초기화 까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. @PreDestroy 호출 되지 않는다. 웹 관련 스코프 request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다...." }, { "title": "섹션 8 - 빈 생명주기 콜백", "url": "/posts/%EB%B9%88%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%BD%9C%EB%B0%B1/", "categories": "Spring, Basic", "tags": "Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": " 스프링 빈의 이벤트 라이프 사이클스프링 컨테이너 생성 -스프링 빈 생성 - 의존관계 주입 - 초기화 콜백 - 사용 - 소멸전 콜백 - 스프링 종료인터페이스(InitializingBean, DisposableBean)인터페이스를 이용한 빈 생명주기 콜백 사용하기InitializingBean-afterPropertiesSet : Bean 생성후 값 세팅 후 호출됨-destroy : Bean 소멸시 호출됨 단점1 : 스프링 전용 인터페이스에 의존 단점2 : 초기화, 소멸 메소드 이름 변경할 수 없음 코드를 고칠수 없는 외부..." }, { "title": "섹션1 - 객체 지향 설계와 스프링", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%84%A4%EA%B3%84%EC%99%80%EC%8A%A4%ED%94%84%EB%A7%81/", "categories": "Spring, Basic", "tags": "객체지향원칙, SOLID, Spring", "date": "2022-02-26 00:00:00 +0900", "snippet": "좋은 객체 지향 프로그래밍이란? 추상화 캡슐화 상속 다형성좋은 객체 지향 설계의 5가지 원칙 (SOLID) S - Single Responsibility Principle(SRP) 단일 책임 원칙 O - Open/Closed Principle(OCP) L - 리스코프 치환 법칙(Liskov substitution principle) I - Interface Segregation Principle(ISP) 인터페이스 분리 법칙 D - Dependency Inversion Principle(DIP) 의존..." }, { "title": "정수 삼각형(43105)", "url": "/posts/%EC%A0%95%EC%88%98%EC%82%BC%EA%B0%81%ED%98%95/", "categories": "Algorithm, DynamicProgramming", "tags": "DynamicProgramming, 프로그래머스, 알고리즘", "date": "2021-04-25 00:00:00 +0900", "snippet": "Dynamic_Programming(동적계획법)https://programmers.co.kr/learn/courses/30/lessons/43105(level, 위치) - 두 값을 pair로 갖는 객체를 HashMap의 key값으로 하기 위해서Key라는 내부클래스를 만들었다.equals 함수를 overriding 해서 값이 같은 경우에 같다고 하도록 함수를 변경하였다.hashCode는 int 크기가 -2^16 ~ 2^ 16 이라 해당 값으로 하면 값이 unique할거라 생각해서아래 내용대로 구현하였다.정확하지는 않지만HashM..." }, { "title": "네트워크(43162)", "url": "/posts/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/", "categories": "Algorithm, BFS_DFS", "tags": "BFS, 프로그래머스, 알고리즘", "date": "2021-04-20 00:00:00 +0900", "snippet": "처음에는 인접행렬이라 배열의 대각선을 기준으로 반만 확인하려 했지만 0-1-4 큰 순서대로만 연결되는 것이 아닌 0-5-2-3 처럼 연결되는 경우 수가 커졌다가 다시 작아질수도 있어서 아래부분 주석처리했습니다.BFShttps://programmers.co.kr/learn/courses/30/lessons/43162public static int solution(int n, int[][] computers) { int answer = 0; boolean[] visited = new boolean[n]; ..." }, { "title": "N으로 표현하기(42895)", "url": "/posts/N%EC%9C%BC%EB%A1%9C%ED%91%9C%ED%98%84/", "categories": "Algorithm, DynamicProgramming", "tags": "DynamicProgramming, 프로그래머스, 알고리즘", "date": "2021-04-19 00:00:00 +0900", "snippet": "Dynamic_Programming(동적계획법)https://programmers.co.kr/learn/courses/30/lessons/42895public static void dynamic(int N, int n, int number) { ArrayList&amp;lt;Integer&amp;gt; list; if (n == 1) { list = new ArrayList&amp;lt;Integer&amp;gt;(); list.add(N); memList.add(list); } else { Set&am..." } ]
